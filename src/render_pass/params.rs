use std::convert::TryFrom;

use ash::vk;

use crate::{
	prelude::Transparent,
	resource::image::layout::{ImageLayoutAttachment, ImageLayoutFinal}
};

use super::error::SubpassDescriptionError;

#[derive(Debug)]
pub enum AttachmentOps {
	Color {
		load: vk::AttachmentLoadOp,
		store: vk::AttachmentStoreOp
	},
	DepthStencil {
		depth_load: vk::AttachmentLoadOp,
		depth_store: vk::AttachmentStoreOp,
		stencil_load: vk::AttachmentLoadOp,
		stencil_store: vk::AttachmentStoreOp
	}
}

vk_builder_wrap! {
	/// Wrapper struct that is transparent over `vk::AttachmentDescriptionBuilder`.
	pub struct AttachmentDescription {
		builder: vk::AttachmentDescriptionBuilder<'static> => vk::AttachmentDescription
	}
	impl {
		pub fn new(
			may_alias: bool,
			format: vk::Format,
			samples: vk::SampleCountFlags,
			ops: AttachmentOps,
			initial_layout: vk::ImageLayout,
			final_layout: ImageLayoutFinal
		) -> Self {
			let mut builder = vk::AttachmentDescription::builder()
				.format(format)
				.samples(samples)
				.initial_layout(initial_layout)
				.final_layout(final_layout.into())
			;

			if may_alias {
				builder = builder.flags(vk::AttachmentDescriptionFlags::MAY_ALIAS);
			}
			match ops {
				AttachmentOps::Color { load, store } => {
					builder = builder.load_op(load).store_op(store);
				}
				AttachmentOps::DepthStencil { depth_load, depth_store, stencil_load, stencil_store } => {
					builder = builder.load_op(depth_load).store_op(depth_store).stencil_load_op(stencil_load).stencil_store_op(stencil_store);
				}
			}

			AttachmentDescription {
				builder
			}
		}
	}
}

vk_builder_wrap! {
	/// Wrapper struct that is transparent over `vk::AttachmentDescriptionBuilder`.
	pub struct AttachmentReference {
		builder: vk::AttachmentReferenceBuilder<'static> => vk::AttachmentReference
	}
	impl {
		pub fn new(
			attachment_index: Option<u32>,
			layout: ImageLayoutAttachment
		) -> Self {
			let builder = vk::AttachmentReference::builder()
				.attachment(attachment_index.unwrap_or(vk::ATTACHMENT_UNUSED))
				.layout(layout.into())
			;

			AttachmentReference {
				builder
			}
		}
	}
}

vk_builder_wrap! {
	/// Wrapper struct that is transparent `vk::SubpassDescriptionBuilder`.
	pub struct SubpassDescription ['a] {
		builder: vk::SubpassDescriptionBuilder<'a> => vk::SubpassDescription
	}
	impl ['a] {
		pub fn new(
			input_attachments: Option<&'a [AttachmentReference]>,
			color_resolve_attachments: Option<(&'a [AttachmentReference], Option<&'a [AttachmentReference]>)>,
			depth_stencil_attachment: Option<&'a AttachmentReference>,
			preserve_attachments: Option<&'a [u32]>
		) -> Result<Self, SubpassDescriptionError> {
			let color_attachments = color_resolve_attachments.map(|v| v.0);
			let resolve_attachments = color_resolve_attachments.and_then(|v| v.1);

			#[cfg(feature = "runtime_implicit_validations")]
			{
				match (color_attachments, resolve_attachments) {
					(Some(c), Some(r)) => if r.len() != c.len() {
						return Err(SubpassDescriptionError::ResolveAttachmentsLengthMismatch)
					}
					_ => ()
				}
			}

			let mut builder = vk::SubpassDescription::builder();

			if let Some(input_attachments) = input_attachments {
				builder = builder.resolve_attachments(
					Transparent::transmute_slice_twice(input_attachments)
				);
			}
			if let Some(color_attachments) = color_attachments {
				builder = builder.color_attachments(
					Transparent::transmute_slice_twice(color_attachments)
				);
			}
			if let Some(resolve_attachments) = resolve_attachments {
				builder = builder.resolve_attachments(
					Transparent::transmute_slice_twice(resolve_attachments)
				);
			}
			if let Some(depth_stencil_attachment) = depth_stencil_attachment {
				builder = builder.depth_stencil_attachment(
					depth_stencil_attachment.transmute_ref()
				)
			}
			if let Some(preserve_attachments) = preserve_attachments {
				builder = builder.preserve_attachments(
					preserve_attachments
				);
			}

			Ok(
				Self {
					builder
				}
			)
		}
	}
}
impl<'a, I, CR, P> TryFrom<&'a SubpassDescriptionHolder<I, CR, P>> for SubpassDescription<'a>
where
	I: AsRef<[AttachmentReference]>,
	CR: AsRef<[AttachmentReference]>,
	P: AsRef<[u32]>
{
	type Error = super::error::SubpassDescriptionError;

	fn try_from(holder: &'a SubpassDescriptionHolder<I, CR, P>) -> Result<Self, Self::Error> {
		SubpassDescription::new(
			holder.input_attachments.as_ref().map(AsRef::as_ref),
			holder
				.color_resolve_attachments
				.as_ref()
				.map(|(c, r)| (c.as_ref(), r.as_ref().map(AsRef::as_ref))),
			holder.depth_stencil_attachment.as_ref(),
			holder.preserve_attachments.as_ref().map(AsRef::as_ref)
		)
	}
}

/// Struct for holding description generated by `render_pass_description` macro.
#[derive(Debug)]
pub struct SubpassDescriptionHolder<I, CR, P>
where
	I: AsRef<[AttachmentReference]>,
	CR: AsRef<[AttachmentReference]>,
	P: AsRef<[u32]>
{
	pub input_attachments: Option<I>,
	pub color_resolve_attachments: Option<(CR, Option<CR>)>,
	pub depth_stencil_attachment: Option<AttachmentReference>,
	pub preserve_attachments: Option<P>
}
